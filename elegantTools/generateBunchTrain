#!/bin/sh  
# \
exec oagtclsh "$0" "$@"

if {![info exists env(OAG_TOP_DIR)] || [string length $env(OAG_TOP_DIR)]==0} {
    set env(OAG_TOP_DIR) /usr/local
}
set auto_path [linsert $auto_path 0  $env(OAG_TOP_DIR)/oag/apps/lib/$env(HOST_ARCH)]

APSStandardSetup

set usage "usage: generateBunchTrain -input <bunch> {-patternFile <filename> | -patternString <string>} -rfFrequency <Hz> -output <filename> \[-groupByBunch {0|1}(0)\]\n\
The input file should be generated by elegant's bunched_beam command or equivalent; it should contain only one bunch.\n\
The pattern file has two columns: BucketNumber (integer) and Intensity (a value (0,1]).\n\
The pattern string has the form: <n1>*<s1>*<i1> <n2>*<s2>*<i2> ... where <n1> is the number of \n\
bunches, <s1> is the spacing in rf buckets, and <i1> is the relative intensity, etc.\n\
E.g., 5*1*1.0 5*1*0.0 5*2*1.0 specifies two 5-bunch trains separated by 5 empty buckets;\n\
the first train has single-bucket spacing, while the second has two-bucket spacing.\n\n\
Script by M. Borland, 2021."

set args $argv
set input ""
set output ""
set patternFile ""
set patternString ""
set rfFrequency -1
set groupByBunch 0
if {[APSStrictParseArguments {input output patternFile patternString rfFrequency groupByBunch}] || [expr $rfFrequency<0] || ![string length $input] ||
    ![string length $output] || (![string length $patternFile] && ![string length $patternString]) || \
      ([string length $patternFile] && [string length $patternString])} {
    puts stderr "$usage"
    exit 1
}

if ![file exists $input] {
    return -code error "not found: $input"
}

if [file exists $output] {
    return -code error "in use: $output"
}

if [string length $patternString] {
    set bucketList ""
    set intensityList ""
    set bucket 0
    foreach segment [split $patternString " "] {
        set trainList [split $segment "*"]
        set number [lindex $trainList 0]
        set spacing [lindex $trainList 1]
        set intensity [lindex $trainList 2]
        for {set n 0} {$n<$number} {incr n} {
            if [expr $intensity>0] {
                lappend bucketList $bucket
                lappend intensityList $intensity
            }
            set bucket [expr $bucket+$spacing]
        }
    }
    exec sddsmakedataset $output.pattern \
        -column=BucketNumber,type=long -data=[join $bucketList ,] \
        -column=Intensity,type=long -data=[join $intensityList ,]
} else {
    set bucketList [exec sdds2stream -column=BucketNumber $patternFile]
    set intensityList [exec sdds2stream -column=Intensity $patternFile]
}

set maxIntensity 0.0
foreach intensity $intensityList {
    if [expr $intensity>$maxIntensity] {
        set maxIntensity $intensity
    }
}

set n [exec sdds2stream -rows=bare $input]
set fileList ""
set bunch 0
set seed 987654321
foreach bucket $bucketList intensity $intensityList {
    set sample [expr ($intensity*1.0)/$maxIntensity]
    #puts stderr "$bucket $intensity $sample"
    exec sddsprocess $input $output.$bucket "-rpnexpression=$seed srnd" \
      -process=t,ave,%sAve -sample=$sample \
      "-redefine=column,particleID,$bunch $n * particleID +,type=long" \
      "-redefine=parameter,IDSlotsPerBunch,$n,type=long" \
      "-redefine=parameter,BucketSpacing,$rfFrequency rec,units=s" \
      "-redefine=column,t,t tAve - BucketSpacing $bucket * +,units=s"
    incr seed 10
    lappend fileList $output.$bucket
    incr bunch
}

if $groupByBunch {
    eval exec sddscombine $fileList $output -merge
} else {
    eval exec sddscombine $fileList -merge -pipe=out \
	| sddsprocess -pipe "{-define=col,Group,particleID 1 - IDSlotsPerBunch mod,type=long}" \
	| sddssort -pipe=in -column=Group -column=particleID $output
}

eval file delete $fileList
